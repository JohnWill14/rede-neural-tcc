# -*- coding: utf-8 -*-
"""spectrogram-from-eeg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NArbM_tYiqxK7bhxDrBEJsvtv-yOfWAx

# This code is code taken from a amazing notebook by Chris Deotte
[https://www.kaggle.com/code/cdeotte/how-to-make-spectrogram-from-eeg](http://)

# How To Make Spectrograms from EEG
In this notebook, we learn how to make spectrograms from EEG. The EEGs are waveforms and the Spectrograms are images. There is a discussion about this notebook (https://www.kaggle.com/competitions/hms-harmful-brain-activity-classification/discussion/467877).
"""

path_drive = './dataset'

import pandas as pd, numpy as np, os
import matplotlib.pyplot as plt, gc

train = pd.read_csv(f'{path_drive}/train.csv')
print('Train shape', train.shape )

"""# The Bipolar Double Banana Montage
In the Kaggle discussion [here][1], we learn what information we need to make spectrograms from eegs. The following website [here][2] is helpful also. To build 1 spectrogram, we need 1 time series signal. Kaggle provides us with 19 eeg time signals, so we must combine them into 4 time signals to make 4 spectrograms.

In the diagram below, we see which electrode signals are needed to make the `LL, LP, RP, RR` spectrograms. Furthermore Kaggle discussions imply that most likely we create differences between consecutive electrodes and average the differences. For example, we create `LL spectrogram` with the formula:


    LL Spec = ( spec(Fp1 - F7) + spec(F7 - T3) + spec(T3 - T5) + spec(T5 - O1) )/4.
"""

NAMES = ['LL','LP','RP','RR']

FEATS = [['Fp1','F7','T3','T5','O1'],
         ['Fp1','F3','C3','P3','O1'],
         ['Fp2','F8','T4','T6','O2'],
         ['Fp2','F4','C4','P4','O2']]

directory_path = f'{path_drive}/EEG_Spectrograms/'
if not os.path.exists(directory_path):
    os.makedirs(directory_path)

"""# Optional Signal Denoising with Wavelet transform
We can optionally denoise the signal before creating the spectrogram. I'm not sure yet if this creates better or worse spectrograms. We can experiment with this. This code comes from Yusaku5738 notebook [here][1] and was suggested by SeshuRajuP in the comments. We have many parent functions to use for denoising. Yusaku5738 suggests using `wavelet = db8`.

[1]: https://www.kaggle.com/code/yusaku5739/eeg-signal-denosing-using-wavelet-transform
"""

import pywt
print("The wavelet functions we can use:")
print(pywt.wavelist())

USE_WAVELET = None #or "db8" or anything below

# DENOISE FUNCTION
def maddest(d, axis=None):
    return np.mean(np.absolute(d - np.mean(d, axis)), axis)

def denoise(x, wavelet='haar', level=1):
    coeff = pywt.wavedec(x, wavelet, mode="per")
    sigma = (1/0.6745) * maddest(coeff[-level])

    uthresh = sigma * np.sqrt(2*np.log(len(x)))
    coeff[1:] = (pywt.threshold(i, value=uthresh, mode='hard') for i in coeff[1:])

    ret=pywt.waverec(coeff, wavelet, mode='per')

    return ret

"""# Create Spectrograms with Librosa
We can use library librosa to create spectrograms. We will save them to disk. For each `eeg_id` we will make 1 spectrogram from the middle 50 seconds. We don't want to use more information than 50 seconds at a time because during test inference, we only have access to 50 seconds of EEG for each test `eeg_id`. We will create spectrograms of `size = 128x256 (freq x time)`.

The main function is

    mel_spec = librosa.feature.melspectrogram(y=x, sr=200, hop_length=len(x)//256,
              n_fft=1024, n_mels=128, fmin=0, fmax=20, win_length=128)
              
Let's explain these variables.
* `y` is the input time series signal
* `sr` is the sampling frequency. In this competition EEG is sample 200 times per sec
* `hop_length` produces image with `width = len(x)/hop_length`
* `n_fft` controls vertical resolution and quality of spectrogram
* `n_mels` produces image with `height = n_mels`
* `fmin` is smallest frequency in our spectrogram
* `fmax` is largest frequency in our spectrogram
* `win_length` controls hortizonal resolution and quality of spectrogram
"""

import librosa

def spectrogram_from_eeg(parquet_path, display=False):

    # LOAD MIDDLE 50 SECONDS OF EEG SERIES
    eeg = pd.read_parquet(parquet_path)
    middle = (len(eeg)-10_000)//2
    eeg = eeg.iloc[middle:middle+10_000]

    # VARIABLE TO HOLD SPECTROGRAM
    img = np.zeros((128,256,4),dtype='float32')

    if display: plt.figure(figsize=(10,7))
    signals = []
    for k in range(4):
        COLS = FEATS[k]

        for kk in range(4):

            # COMPUTE PAIR DIFFERENCES
            x = eeg[COLS[kk]].values - eeg[COLS[kk+1]].values

            # FILL NANS
            m = np.nanmean(x)
            if np.isnan(x).mean()<1: x = np.nan_to_num(x,nan=m)
            else: x[:] = 0

            # DENOISE
            if USE_WAVELET:
                x = denoise(x, wavelet=USE_WAVELET)
            signals.append(x)

            # RAW SPECTROGRAM
            mel_spec = librosa.feature.melspectrogram(y=x, sr=200, hop_length=len(x)//256,
                  n_fft=1024, n_mels=128, fmin=0, fmax=20, win_length=128)

            # LOG TRANSFORM
            width = (mel_spec.shape[1]//32)*32
            mel_spec_db = librosa.power_to_db(mel_spec, ref=np.max).astype(np.float32)[:,:width]

            # STANDARDIZE TO -1 TO 1
            mel_spec_db = (mel_spec_db+40)/40
            img[:,:,k] += mel_spec_db

        # AVERAGE THE 4 MONTAGE DIFFERENCES
        img[:,:,k] /= 4.0

    return img

if __name__ == '__main__':

    PATH = f'{path_drive}/train_eegs/'
    DISPLAY = 100
    EEG_IDS = train.eeg_id.unique()
    all_eegs = {}

    for i,eeg_id in enumerate(EEG_IDS):
        if (i%100==0)&(i!=0): print(i,', ',end='')

        if(i<=13200):
            continue

        # CREATE SPECTROGRAM FROM EEG PARQUET
        img = spectrogram_from_eeg(f'{PATH}{eeg_id}.parquet', i<DISPLAY)

        np.save(f'{directory_path}{eeg_id}',img)
        all_eegs[eeg_id] = img

    # SAVE EEG SPECTROGRAM DICTIONARY
    np.save('eeg_specs',all_eegs)